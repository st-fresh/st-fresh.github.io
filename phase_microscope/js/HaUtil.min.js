var MEUtil = MEUtil || {};

/*---------- Public Properties ----------*/
MEUtil.vendorPrefix = {};

MEUtil.IS_TOUCH_DEVICE = (function (userAgent) {
    if (userAgent.match(/Android/i) ||
        userAgent.match(/webOS/i) ||
        userAgent.match(/iPhone/i) ||
        userAgent.match(/iPad/i) ||
        userAgent.match(/iPod/i) ||
        userAgent.match(/BlackBerry/) ||
        userAgent.match(/Windows Phone/i) ||
        userAgent.match(/ZuneWP7/i)) {                
        return true;
    }
    else { return false; }
})(navigator.userAgent);

MEUtil.PIXEL_RATIO = (function () {
    var ctx = document.createElement("canvas").getContext("2d"),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();

MEUtil.PREFIXES = ["webkit", "moz", "o", "ms"];

/*---------- Public Methods ----------*/
MEUtil.appendChildren = function(parent, children) {
    if (parent.substring) { parent = document.getElementById(parent); }
    for (var i = 0, l = children.length; i < l; i++) {
        parent.appendChild(children[i]);
    }
};

MEUtil.createCanvas = function(width, height) {
    var can = document.createElement("canvas");
    can.width = width;
    can.height = height;
    return can;
};

MEUtil.createHiDPICanvas = function(w, h, ratio) {
    if (!ratio) { ratio = MEUtil.PIXEL_RATIO; }
    var can = document.createElement("canvas");
    can.width = w * ratio;
    can.height = h * ratio;
    can.style.width = w + "px";
    can.style.height = h + "px";
    can.getContext("2d").setTransform(ratio, 0, 0, ratio, 0, 0);
    return can;
};

MEUtil.formatWithComma = function(str) {
    return str.toString().replace(/(\d)(?=(\d{3})+$)/, "$1,");
};

MEUtil.getGlobalX = function(o) {
    var x = 0;
    do { x += o.offsetLeft; } while (o = o.offsetParent);
    return x;
};

MEUtil.makeSuper = function(Man, SuperMan) {
    function F() {}
    F.prototype = SuperMan.prototype;

    var prototype = new F();
    prototype.constructor = Man;
    Man.prototype = prototype;
};

MEUtil.on = function(element, types, callback) {
    var typesArr = types.split(" ");
    for (var i = 0, l = typesArr.length; i < l; i++) {
        element.addEventListener(typesArr[i], callback, false);
    }
};

MEUtil.off = function(element, types, callback) {
    var typesArr = types.split(" ");
    for (var i = 0, l = typesArr.length; i < l; i++) {
        element.removeEventListener(typesArr[i], callback, false);
    }
};

MEUtil.upscaleCanvas = function(can, ratio) {
    if (can.substring) { can = document.getElementById(can); }
    if (!ratio) { ratio = MEUtil.PIXEL_RATIO; }
    var w = can.clientWidth || can.width,
        h = can.clientHeight || can.height,
        ctx = can.getContext("2d");
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    can.width = w * ratio;
    can.height = h * ratio;
    can.style.width = w + "px";
    can.style.height = h + "px";
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return can;
};

MEUtil.loadFromDataSrc = function(assets, options) {    
    var count = assets.length;

    for (var i = 0, l = count; i < l; i++) {
        var item = assets[i];
        if (typeof item != "string") {
            loadAssetFromDataSrc(item);
        }else {
            loadAssetFromPath(item);
        }        
    }

    function loadAssetFromDataSrc(asset) {
        var path = asset.getAttribute("data-src");

        asset.removeAttribute("data-src");

        var img = new Image();
        img.onload = getImgLoadedFunction(asset);
        img.src = path;
    }

    function loadAssetFromPath(path) {
        var img = new Image();
        img.onload = getImgLoadedFunction();
        img.src = path;
    }

    function getImgLoadedFunction(el) {
        return function() {
            count--;

            // Re-attach the loaded asset, if available.
            if (el) {
                switch (el.tagName.toLowerCase()) {
                case "img":
                    el.src = this.src;
                    break;
                case "div":
                    el.style.backgroundImage = "url(" + this.src + ")";
                    break;
                case "object":
                    el.data = this.src;
                    break;
                case "canvas":
                    var ctx = el.getContext("2d");
                    ctx.drawImage(this, 0, 0);
                }
            }

            // Update loading events, if available.
            if (options) {
                if (options.onProgress) { 
                    options.onProgress({
                        type: "progress",
                        response: el, 
                        progress: 1 - count / l
                    });
                }

                if (!count && options.onComplete) { 
                    options.onComplete({
                        type: "complete",
                        response: assets
                    }); 
                }
            }
        };
    }
};

MEUtil.raf = (function() {
    var requestAnimationFrame = 
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
            window.setTimeout(callback, 1000 / 60);
        };

    return function(callback) {
        requestAnimationFrame(callback);
    };
})();

/*MEUtil._cachedEvents = {};

MEUtil.setPrefixedEvent = function(el, evtType, callback) {
    var cachedEvents = MEUtil._cachedEvents
    if (cachedEvents.hasOwnProperty(evtType)) {
        console.log("Event was cached.");
        el.addEventListener(cachedEvents[evtType], callback, false);
    }else {
        var prefixes = MEUtil.PREFIXES,
            lcType = evtType.toLowerCase(),
            prop = "on" + lcType;

        // console.log(prop);

        if (prop in window) {
            cachedEvents[evtType] = lcType;
            el.addEventListener(lcType, callback, false);
            console.log("Found " + lcType);
        }else {
            for (var i = 0, l = prefixes.length; i < l; i++) {
                prop = "on" + prefixes[i] + lcType;
                if (prop in window) {
                    cachedEvents[evtType] = prefixes[i] + evtType;
                    el.addEventListener(prefixes[i] + evtType, callback, false);
                    console.log("Found " + prefixes[i] + evtType);
                    break;
                }
            }
        }
    }
};*/

MEUtil.setPrefixedEvent = function(el, evtType, callback) {
    var prefixes = MEUtil.PREFIXES;
    for (var i = 0, l = prefixes.length; i < l; i++) {
        el.addEventListener(prefixes[i] + evtType, callback, false);
    }
    el.addEventListener(evtType.toLowerCase(), callback, false);
};

MEUtil.removePrefixedEvent = function(el, evtType, callback) {
    var prefixes = MEUtil.PREFIXES;
    for (var i = 0, l = prefixes.length; i < l; i++) {
        el.removeEventListener(prefixes[i] + evtType, callback, false);
    }
    el.removeEventListener(evtType.toLowerCase(), callback, false);
};

MEUtil.getPrefixedProp = function(prop) {
    if (MEUtil.vendorPrefix[prop]) {
        return MEUtil.vendorPrefix[prop];
    }else {
        var prefixes = MEUtil.PREFIXES,
            el = document.createElement("div"),
            ref = MEUtil.vendorPrefix,
            lowProp = prop.charAt(0).toLowerCase() + prop.slice(1),
            highProp = prop.charAt(0).toUpperCase() + prop.slice(1);

        if (lowProp in el.style) {
            ref[prop] = lowProp;
        }else {
            var preProp = "";
            ref[prop] = null;
            for (var i = 0, l = prefixes.length; i < l; i++) {
                preProp = prefixes[i] + highProp;
                if (preProp in el.style) {
                    ref[prop] = preProp;
                    break;
                }
            }
        }

        MEUtil.vendorPrefix[prop] = ref[prop];
        return ref[prop];
    }
};

MEUtil.setRuleProperty = function(selector, prop, val) {
    var sheets = document.styleSheets,
        rules = null,
        ii = 0, l = 0;

    for (var i = sheets.length - 1; i > -1; i--) {
        rules = sheets[i].cssRules;
        l = rules.length;
        for (ii = 0; ii < l; ii++) {
            if (rules[ii].selectorText === selector) {
                rules[ii].style.setProperty(prop, val, null);
                i = -1;
                break;
            }
        }
    }
};

/*----------- Class definition for Hamamatsu Event ----------*/
/*This custom event object is incredibly basic because
that is all it needs to be.  Normal Javascript Events 
have a lot of unnecessary information that does not apply
to our needs.*/
function HaEvent(type, target) {
    return {
        target: target,
        timeStamp: Date.now(),
        type: type
    };
}

/*----------- Class definition for Hamamatsu Splash ----------*/
function HaSplash(tutId) {
    if (!(this instanceof HaSplash)){
        return new HaSplash(tutId);
    }

    var splashContainer = document.createElement("div"),
        loadContainer = document.createElement("div"),
        tut = document.getElementById(tutId);

    splashContainer.className = "ha-splashContainer";
    loadContainer.className = "ha-splashBackground";

    splashContainer.appendChild(loadContainer);
    tut.appendChild(splashContainer);

    this._splashContainer = splashContainer;
    this._loadContainer = loadContainer;

    /*------- Set default options on the tutorial contaner --------*/
    var tapHighlight = MEUtil.getPrefixedProp("tapHighlightColor");
    tut.style[tapHighlight] = "rgba(0,0,0,0)";
    if (MEUtil.IS_TOUCH_DEVICE) {
        tut.addEventListener("touchmove", function(event) {
            if (event.type === "touchmove") {
                if (event.touches.length === 1) {
                    event.preventDefault();
                }
            }
        }, false);
    }
}

HaSplash.prototype.init = function(callback, imagePaths) {
    var that = this,
        logo = document.createElement("img"),
        graphCont = document.createElement("div"),
        graphBack = document.createElement("img"),
        curve = document.createElement("object"),
        curveFill = document.createElement("img"),
        loadText = document.createElement("div"),
        graphNumCont = document.createElement("div"),
        graphNums = [],
        numString = 0;

    initSplash();

    function initSplash() {
        curve.setAttribute("type", "image/svg+xml");

        logo.className = "ha-splashLogo";
        graphCont.className = "ha-mainWindow ha-splashGraphContainer";
        graphBack.className = "ha-splashGraphBack";
        curve.className = "ha-splashCurve";
        curveFill.className = "ha-splashCurveFill";
        graphNumCont.className = "ha-splashNumberContainer";
        loadText.className = "ha-splashText ha-splashTextLoad";
        
        loadText.innerHTML = "Loading (%)";

        var rootPath = "/html5/Hamamatsu/includes/images/";
        logo.setAttribute("data-src", rootPath + "hamamatsulogo.svg");
        graphBack.setAttribute("data-src", rootPath + "splashgraphback.svg");
        curve.setAttribute("data-src", rootPath + "splashCurve.svg");
        curveFill.setAttribute("data-src", rootPath + "splashCurveFill.png");

        MEUtil.loadFromDataSrc([logo, graphBack, curve, curveFill],
            {onComplete: (function(loadContainer) { 
                return function() {
                    for (var x = 0; x < 332; x+=33) {
                        var div = document.createElement("div");
                        div.className = "ha-splashText ha-splashTextNum";
                        div.style.left = x + "px";
                        div.innerHTML = numString;
                        graphNumCont.appendChild(div);
                        graphNums.push(div);
                        numString += 10;
                    }

                    MEUtil.appendChildren(graphCont, [graphBack, curveFill, curve]);

                    var frag = document.createDocumentFragment();
                    MEUtil.appendChildren(frag, [logo, graphCont, graphNumCont, loadText]);
                    loadContainer.appendChild(frag);

                    graphNums.forEach(function(div, n) {
                        div.style[MEUtil.getPrefixedProp(
                            "AnimationDelay")] = (0.7 + n * 0.05) + "s";
                        if (n === 10) {
                            MEUtil.setPrefixedEvent(div, "AnimationEnd", startPreload);
                        }
                    });   
                };})(that._loadContainer)
            });
    }

    function startPreload() {
        var inc = 26,
            clipW = 0,
            currentW = 0,
            curveW = curveFill.clientWidth,
            endClip = "px, " + curveFill.clientHeight + "px, 0)",
            allAssets = [];

        // Compile all assets to load.
        (function() {
            var pathElements = document.querySelectorAll("[data-src]");
            for (var i = 0, l = pathElements.length; i < l; i++) {
                allAssets.push(pathElements[i]);
            }
            if (imagePaths) {
                l = imagePaths.length
                for (i = 0; i < l; i++) {
                    allAssets.push(imagePaths[i]);
                }
            }
        })();

        // Begin the loading bar animation loop.
        MEUtil.raf(function loadLoop() {
            var cw = currentW;

            if (clipW < curveW) {
                MEUtil.raf(loadLoop);
            }else {
                setTimeout(function() {
                    MEUtil.raf(reverseSplashAnimation);
                }, 500);
            }

            if (clipW < cw) {
                if (clipW <= cw - inc) {
                    clipW += inc;
                }else { clipW = cw; }
                curveFill.style.clip = "rect(0, " + clipW + endClip;
            }
        });

        // If there are assets to load, load them.  Otherwise, set load bar to max.
        if (allAssets.length) {
            MEUtil.loadFromDataSrc(allAssets, {
                onProgress: function(e) { 
                    currentW = e.progress * curveW; 
                }
            });
        }else { currentW = curveW; }
    }

    function reverseSplashAnimation() {
        logo.classList.add("ha-splashLogoReverse");
        graphBack.classList.add("ha-splashGraphBackReverse");
        curve.classList.add("ha-splashCurveReverse");
        curveFill.classList.add("ha-splashCurveFillReverse");
        graphNumCont.classList.add("ha-splashNumberContainerReverse");
        loadText.classList.add("ha-splashTextLoadReverse");
        graphCont.classList.add("ha-splashGraphContainerReverse");

        setTimeout(function() {
            if (callback) { MEUtil.raf(callback); }
        }, 550);
    }
};

HaSplash.prototype.fadeOut = function(callback) {
    var handleTransitionEnd = function() {
        this._splashContainer.parentNode.removeChild(this._splashContainer);
        if (callback) { callback.call(); }
    };

    MEUtil.setPrefixedEvent(this._splashContainer, "TransitionEnd",
        handleTransitionEnd.bind(this), false);

    document.getElementsByClassName(
        "ha-mainscene")[0].style.visibility = "visible";

    this._splashContainer.style.opacity = 0;
};

/*----------- Class definition for Hamamatsu Component ----------*/
function HaComponent(id) {
    if (id) {
        this._container = typeof id === "string" ?
            document.getElementById(id) : id;
        this._isEnabled = true;
        
        if (MEUtil.IS_TOUCH_DEVICE) {
            this._container.addEventListener("touchstart", function(e) {
                /*Prevent any default actions from the browser when a user
                interacts with the component*/
                e.preventDefault();
            }, false);
        }
    }else {
        console.error(id + " is not a valid id string or HTMLElement.");
    }
}

HaComponent.prototype.addEventListener = function(type, listener) {
    type = "on" + type;
    var handlers = this[type];
    if (handlers) {
        if (typeof handlers === "function") {
            this[type] = [handlers, listener];
        }else {
            this[type].push(listener);
        }
    }else {
        this[type] = [listener];
    }
};

HaComponent.prototype.getElement = function() {
    return this._container;
};

HaComponent.prototype.getEnabled = function() {
    return this._isEnabled;
};

HaComponent.prototype.setEnabled = function(isEnabled) {
    if (isEnabled != this._isEnabled) {
        if (isEnabled) {
            this._enable();
        }else {
            this._disable();
        }
    }
};

HaComponent.prototype._enable = function() {
    var style = this._container.style;
    var funcWrapper = (function(that) {
        function transEndListener(event) {
            var style = event.currentTarget.style;
            MEUtil.removePrefixedEvent(this._container, "TransitionEnd", funcWrapper);
            style.cursor = "pointer";
            this._isEnabled = true;
        }
        return transEndListener.bind(that);
    })(this);
    MEUtil.setPrefixedEvent(this._container, "TransitionEnd", funcWrapper);
    style.opacity = "1";
};

HaComponent.prototype._disable = function() {
    var style = this._container.style;
    this._isEnabled = false;
    style.cursor = "default";
    style.opacity = 0.5;
};

HaComponent.prototype._dispatchEvent = function(type) {
    var handlers = this["on" + type];
    if (typeof handlers === "function") {
        handlers.call(this, new HaEvent(type, this));
    }else if (handlers) {
        for (var i = 0, l = handlers.length; i < l; i++) {
            handlers[i].call(this, new HaEvent(type, this));
        }
    }
};

/*----------- Class definition for Hamamatsu Slider ----------*/
function HaSlider(id, initPosition) {
    //Kills the need for 'new' operator.
    if (!(this instanceof arguments.callee)){
        return new arguments.callee(id, initPosition);
    }

    HaComponent.call(this, id);

    /*---------- Public Properties ----------*/
    this.hasChanged = false;
    this.onchange = null;
    this.ontouchstart = null;
    this.ontouchend = null;
    this.tickCount = 0;

    /*---------- Private Properties (DO NOT USE) ----------*/
    this._containerX = 0;
    this._config = {
        CSS: {
            container: "ha-slider",
            handle: {
                border: {
                    down: "ha-sliderHandleBorderDown",
                    up: "ha-sliderHandleBorderUp"
                },
                fill: {
                    down: "ha-sliderHandleFillDown",
                    up: "ha-sliderHandleFillUp"
                }
            },
            track: {
                border: "ha-sliderTrackBorder",
                fill: "ha-sliderTrackFill",
                thresh: "ha-sliderTrackThresh"
            }
        }
    };
    this._bounds = {
        left: 0,
        width: 0
    },
    this._eventFlags = {
        start: false,
        move: false,
        end: false
    }; 
    this._eventListener = MEUtil.IS_TOUCH_DEVICE ?
        this._touchHandler.bind(this) : this._mouseHandler.bind(this);
    this._handle = {
        border: document.createElement("div"),
        fill: document.createElement("div"),
        height: 0,
        innerWidth: 0,
        offset: 0,
        position: 0,
        width: 0,
        x: 0
    };
    this._isActive = false;
    this._thresh = {
        updating: false,
        element: document.createElement("div"),
        min: 0,
        max: 1
    },
    this._track = {
        border: document.createElement("div"),
        fill: document.createElement("div"),
        width: 0
    };
    this._tween = false;

    /*---------- Init HaSlider ----------*/
    //Style
    var css = this._config.CSS;
    this._container.classList.add(css.container);
    this._track.border.classList.add(css.track.border);
    this._track.fill.classList.add(css.track.fill);
    this._track.fill.classList.add("ha-webkitMaskOverflowFix");
    this._thresh.element.classList.add(css.track.thresh);
    this._handle.border.classList.add(css.handle.border.up);
    this._handle.fill.classList.add(css.handle.fill.up);

    var handleTransitionEnd = function() {
        // if (this.tickCount < 2) {
            this._setTween(false);
        // }
    };
    MEUtil.setPrefixedEvent(this._handle.border, "TransitionEnd", 
        handleTransitionEnd.bind(this));

    this._track.fill.appendChild(this._thresh.element);
    this._track.border.appendChild(this._track.fill);
    this._handle.border.appendChild(this._handle.fill);
    MEUtil.appendChildren(this._container, [this._track.border, this._handle.border]);

    //Initialize
    this._track.fill.style.width = (this._container.clientWidth - 6) + "px";    
    this._containerX = function() {
        return MEUtil.getGlobalX(this._container) - this._pointerOffset;
    };
    this._handle.height = this._handle.border.offsetHeight;
    this._handle.width = this._handle.border.offsetWidth;
    this._handle.innerWidth = 6;
    this._handle.offset = 4;
    this._bounds.left = this._handle.border.offsetLeft;
    this._bounds.width = this._container.clientWidth - this._handle.width -
        (this._bounds.left * 2);
    this._track.width = this._thresh.element.offsetWidth;

    this._container.addEventListener(MEUtil.IS_TOUCH_DEVICE ?
        "touchstart" : "mousedown", this._eventListener, false);

    this.setPosition(initPosition || 0);
}

MEUtil.makeSuper(HaSlider, HaComponent);

HaSlider.prototype.getMinThreshold = function() {
    return this._thresh.max;
};

HaSlider.prototype.getMaxThreshold = function() {
    return this._thresh.min;
};

HaSlider.prototype.getPosition = function(min, max) {
    var pos = this._handle.position;
    if (arguments.length) {
        if (max === undefined) {
            return pos * min;
        }
        return min + pos * (max - min);
    }
    return pos;
};

HaSlider.prototype.setMinThreshold = function(min) {
    var thresh = this._thresh;
    if (!isNaN(min) && min !== thresh.min) {
        if (min < 0) { min = 0; }

        if (min !== thresh.min) {
            var delta = this._getThreshMaxX(thresh.max) - this._getThreshMinX(min);
            if (delta < this._handle.innerWidth) {
                min = this._getThreshMinPercent(minX);
            }

            thresh.min = min;
            this._updateThreshold();
        }
    }
};

HaSlider.prototype.setMaxThreshold = function(max) {
    var thresh = this._thresh;
    if (!isNaN(max) && max !== thresh.max) {
        if (max > 1) { max = 1; }

        if (max !== thresh.max) {
            var delta = this._getThreshMaxX(max) - this._getThreshMinX(thresh.min);
            if (delta < this._handle.innerWidth) {
                max = this._getThreshMaxPercent(maxX);
            }

            thresh.max = max;
            this._updateThreshold();
        }
    }
};

HaSlider.prototype.setPosition = function(newPos, shouldTween) {
    if (typeof newPos === "number" && newPos >= 0 && newPos <= 1) {
        if (shouldTween) {
            this._setTween(true);
        }
        this._prepareHandleTranslation(newPos,
            shouldTween);
    }else {
        console.error(newPos + " is not a valid argument for " +
            this._container.id + ".setPosition()");
    }
};

/* Private Properties */
HaSlider.prototype._pointerOffset = MEUtil.IS_TOUCH_DEVICE ? -10 : -8;

/* Private Methods */
HaSlider.prototype._displayLoop = function() {
    if (this._isActive) { MEUtil.raf(this._displayLoop.bind(this)); }

    var flags = this._eventFlags;

    if (flags.start) {
        flags.start = false;
        var handleCSS = this._config.CSS.handle;
        this._handle.border.classList.add(handleCSS.border.down);
        this._handle.fill.classList.add(handleCSS.fill.down);
    }

    if (flags.move) {
        flags.move = false;
        this._moveHandle();
    }

    if (flags.end) {
        flags.end = false;
        var handleCSS = this._config.CSS.handle;
        this._handle.border.classList.remove(handleCSS.border.down);
        this._handle.fill.classList.remove(handleCSS.fill.down);
    }
};

HaSlider.prototype._getThreshMinPercent = function(minX) {
    return minX / (this._track.width - this._handle.innerWidth);
};

HaSlider.prototype._getThreshMaxPercent = function(maxX) {
    var iw = this._handle.innerWidth;
    return (maxX - iw) / (this._track.width - iw);
};

HaSlider.prototype._getThreshMinX = function(min) {
    return min * (this._track.width - this._handle.innerWidth);
};

HaSlider.prototype._getThreshMaxX = function(max) {
    var iw = this._handle.innerWidth;
    return iw + (max * (this._track.width - iw));
};

HaSlider.prototype._getLocalX = function(touchX) {
    return touchX - this._containerX();
};

HaSlider.prototype._handleTouchStart = function(touchX) {
    if (!this._tween) {
        this._setTween(true);
    }
    this._isActive = true;
    this._eventFlags.start = true;
    this._prepareHandleTranslation(this._pxToPos(this._getLocalX(touchX)));
    MEUtil.raf(this._displayLoop.bind(this));
    this._dispatchEvent("touchstart");
};

HaSlider.prototype._handleTouchMove = function(touchX) {
    if (this._tween && this.tickCount < 2) {
        this._setTween(false);
    }
    this._prepareHandleTranslation(this._pxToPos(this._getLocalX(touchX)));
};

HaSlider.prototype._handleTouchEnd = function() {
    this._eventFlags.end = true;
    this._isActive = false;
    this._dispatchEvent("touchend");
};

HaSlider.prototype._mouseHandler = function(event) {
    event.stopPropagation();
    event.preventDefault();
    switch (event.type) {
    case "mousemove":
        this._handleTouchMove(event.clientX);
        break;
    case "mousedown":
        if (event.which === 1 && this._isEnabled) {
            this._container.removeEventListener("mousedown",
                this._eventListener);
            MEUtil.on(document, "mousemove mouseup",
                this._eventListener);

            this._handleTouchStart(event.clientX);
        }
        break;
    case "mouseup":
        MEUtil.off(document, "mousemove mouseup", this._eventListener);
        this._container.addEventListener("mousedown",
            this._eventListener);

        this._handleTouchEnd();
    }
};

HaSlider.prototype._moveHandle = function() {
    this._handle.border.style[MEUtil.getPrefixedProp("Transform")] = 
        "translateX(" + this._handle.x + "px)";
};

HaSlider.prototype._posToPx = function(dec) {
    return (0.5 + dec * this._bounds.width) | 0;
};

HaSlider.prototype._pxToPos = function(px) {
    return px / this._bounds.width;
};

HaSlider.prototype._prepareHandleTranslation = function(pos) {
    var handle = this._handle,
        thresh = this._thresh;

    if (this.tickCount > 1) {
        var n = this.tickCount - 1;
        pos = ((0.5 + (pos * n)) >> 0) / n;
    }

    /*  Constrain newX to the threshold.
        This will not work with ticks   */
    if (pos < thresh.min) {
        pos = thresh.min;
    }else if (pos > thresh.max) {
        pos = thresh.max;
    }

    if (pos !== handle.position) {
        handle.position = pos;
        handle.x = this._posToPx(pos);
        this._eventFlags.move = true;
        this.hasChanged = true;
        if (!this._isActive) {
            MEUtil.raf(this._displayLoop.bind(this));
        }
        this._dispatchEvent("change");
    }
};

HaSlider.prototype._setTween = function(shouldTween) {
    if (this._tween !== shouldTween) {
        this._handle.border.classList[shouldTween ?
            "add" : "remove"]("ha-sliderHandleTween");
        this._tween = shouldTween;
    }
};

HaSlider.prototype._touchHandler = function(event) {
    switch (event.type) {
    case "touchmove":        
        var touches = event.changedTouches;
        for (var i = 0, l = touches.length; i < l; i++) {
            if (this._touch.identifier === touches[i].identifier) {
                this._handleTouchMove(touches[i].pageX);
                break;
            }
        }
        break;
    case "touchstart":
        if (this._isEnabled) {
            this._container.removeEventListener("touchstart",
                this._eventListener);
            MEUtil.on(document, "touchmove touchend touchcancel",
                this._eventListener);

            var touch = event.changedTouches[0];
            this._touch = touch;
            this._handleTouchStart(touch.pageX);
        }
        break;
    case "touchcancel": //Fall-through
    case "touchend":
        var touches = event.changedTouches;
        for (var i = 0, l = touches.length; i < l; i++) {
            if (this._touch.identifier === touches[i].identifier) {
                MEUtil.off(document, "touchmove touchend touchcancel",
                    this._eventListener);
                this._container.addEventListener("touchstart",
                    this._eventListener);

                this._handleTouchEnd();
                break;
            }
        }
    }
};

HaSlider.prototype._updateThreshold = function() {
    if (!this._thresh.updating) {
        this._thresh.updating = true;

        var update = function() {
                var thresh = this._thresh,
                    clip = "rect(0 " + Math.round(this._getThreshMaxX(thresh.max)) +
                        "px " + thresh.element.clientHeight + "px " +
                        Math.round(this._getThreshMinX(thresh.min)) + "px)";
                thresh.element.style.clip = clip;
                thresh.updating = false;
                this.setPosition(this.getPosition());
            };

        MEUtil.raf(update.bind(this));
    }  
};

/* ---------- Hamamatsu Button ------------ */

function HaButton(id, isToggle) {
    //Kills the need for 'new' operator.
    if (!(this instanceof arguments.callee)) {
        return new arguments.callee(id, isToggle);
    }

    HaComponent.call(this, id);

    /*---------- Public Properties ----------*/
    this.text = document.createElement("div");
    this.toggleText = null;
    this.ontouchstart = null;
    this.ontouch = null;

    /*---------- Private Properties (DO NOT USE) ----------*/
    this._isEnabled = true;
    this._isToggle = isToggle;
    this._isToggledOn = false;

    /*---------- Private Methods (DO NOT USE) ----------*/
    this._eventListener = MEUtil.IS_TOUCH_DEVICE ?
        this._touchHandler.bind(this) : this._mouseHandler.bind(this);

    /*---------- Init HaButton ----------*/
    this._container.classList.add("ha-button");

    var w = this._container.clientWidth,
        h = this._container.clientHeight;
    this.text.style.lineHeight = h + "px";
    this.text.classList.add("ha-buttonText");
    this.text.innerHTML = this._container.innerHTML;

    this._container.innerHTML = "";

    if (isToggle) {
        var crater = document.createElement("div");
        this.text.style.left = "24px";
        this.text.style.width = (w - 29) + "px";
        crater.classList.add("ha-buttonCrater");
        crater.style[MEUtil.getPrefixedProp("Transform")] = "translate(5px, " +
            ((h - 14) / 2) + "px)";
        this._light = document.createElement("div");
        this._light.classList.add("ha-buttonLight");

        crater.appendChild(this._light);
        this._container.appendChild(crater);
    }

    this._container.appendChild(this.text);

    //Attach initial handlers
    this._container.addEventListener(MEUtil.IS_TOUCH_DEVICE ?
        "touchstart" : "mousedown", this._eventListener);
}

MEUtil.makeSuper(HaButton, HaComponent);

HaButton.prototype.getToggleState = function() {
    return this._isToggledOn;
};

HaButton.prototype.setToggleState = function(isToggledOn, shouldCallEvent) {
    this._setToggle(isToggledOn);

    if (shouldCallEvent) {
        if (this.ontouch) { MEUtil.raf(this.ontouch.bind(this)); }
    }
};

/*---------- Private Properties (DO NOT USE) ----------*/
HaButton.prototype._mouseHandler = function(event) {
    event.stopPropagation();
    event.preventDefault();
    var container = this._container;
    switch (event.type) {
    case "mousedown":
        if (event.which === 1 && this._isEnabled) {
            container.removeEventListener("mousedown",
                this._eventListener);
            MEUtil.on(container, "mouseup mouseout", this._eventListener);

            this._setStateDown();
        }
        break;
    case "mouseout":
    case "mouseup":
        MEUtil.off(container, "mouseup mouseout", this._eventListener);
        container.addEventListener("mousedown", this._eventListener);

        this._setStateUp();
    }
};

HaButton.prototype._touchHandler = function(event) {
    var container = this._container;
    switch (event.type) {
    case "touchstart":
        if (this._isEnabled) {
            this._touch = event.changedTouches[0];

            container.removeEventListener("touchstart", this._eventListener);
            MEUtil.on(container, "touchend touchcancel", this._eventListener);

            this._setStateDown();
        }
        break;
    case "touchcancel": //Fall-through
    case "touchend":
        var touches = event.changedTouches;
        for (var i = 0, l = touches.length; i < l; i++) {
            if (this._touch.identifier === touches[i].identifier) {
                MEUtil.off(container, "touchend touchcancel",
                    this._eventListener);
                container.addEventListener("touchstart", this._eventListener);

                this._setStateUp();
                break;
            }
        }
    }
};

HaButton.prototype._setToggle = function(newState) {
    this._isToggledOn = newState;
    this._light.style.opacity = newState ? 1 : 0;
    if (this.toggleText) {
        if (this.toggleText.length > 1) {
            this.text.innerHTML = this.toggleText[+newState];
        }else {
            this.text.innerHTML = this.toggleText[0];
        }
    }
};

HaButton.prototype._setStateUp = function() {
    this._container.classList.remove("ha-buttonDown");
    if (this._isToggle) {
        this._setToggle(!this._isToggledOn);
    }
    this._dispatchEvent("touch");
};

HaButton.prototype._setStateDown = function() {
    this._container.classList.add("ha-buttonDown");
    this._dispatchEvent("touchstart");
};

//Class Definition for Hamamatsu Segment Button
function HaRadioGroup(id, options) {
    //Kills the need for 'new' operator.
    if (!(this instanceof arguments.callee)) {
        return new arguments.callee(id, options);
    }

    HaComponent.call(this, id);

    options = options || {};

    /*---------- Public Events ----------*/
    this.onchange = null;
    this.ontouchstart = null;

    /*---------- Private Properties ----------*/
    this._config = {
        CSS: {
            group: "ha-radioGroup",
            button: "ha-radioButton",
            horizontal: "ha-horizontalRadioGroup",
            vertical: "ha-verticalRadioGroup",
            selected: "ha-radioButtonSelected"
        }
    };  
    this._borderRadius = options.borderRadius || "3px";
    this._btns = this._createButtonArray(this._container.children);
    this._eventListener = MEUtil.IS_TOUCH_DEVICE ?
        this._touchHandler.bind(this) : this._mouseHandler.bind(this);
    this._gutterSize = "1px";
    this._orientation = options.orientation &&
        options.orientation.toLowerCase() || "horizontal"; 
    this._selectedBtn = null;
    this._touches = null;

    /*---------- Initial Setup ----------*/
    this._container.classList.add("ha-webkitMaskOverflowFix");
    this._addClass(this._container, "group");
    this._updateButtons();
    this._attachHandlers();
}

MEUtil.makeSuper(HaRadioGroup, HaComponent);

HaRadioGroup.prototype.getButtonAtIndex = function(index) {
    return this._btns[index] || null;
};

HaRadioGroup.prototype.getLength = function() {
    return this._btns.length;
};

HaRadioGroup.prototype.getSelectedButton = function() {
    return this._selectedBtn || null;
};

HaRadioGroup.prototype.getSelectedIndex = function() {
    return this._selectedBtn ? this._selectedBtn.haRadioIndex : null;
};

HaRadioGroup.prototype.setBorderRadius = function(newRad, backRad) {
    if (!isNaN(newRad)) {
        backRad = isNaN(backRad) ? newRad + 2 : backRad;

        var css = this._config.CSS;
        MEUtil.setRuleProperty("." + css.horizontal + ":first-child",
            "border-radius", newRad + "px 0 0 " + newRad + "px");
        MEUtil.setRuleProperty("." + css.horizontal + ":last-child",
            "border-radius", "0 " + newRad + "px " + newRad + "px 0");
        MEUtil.setRuleProperty("." + css.vertical + ":first-child",
            "border-radius", newRad + "px " + newRad + "px 0 0");
        MEUtil.setRuleProperty("." + css.vertical + ":last-child",
            "border-radius", "0 0 " + newRad + "px " + newRad + "px");
        MEUtil.setRuleProperty("." + css.group, "border-radius", backRad + "px");
    }
};

HaRadioGroup.prototype.setButtonStyleProperty = function(propName, valArr) {
    var btns = this._btns,
        l = btns.length,
        btn = null;
    if (typeof propName === "string" && typeof valArr === "object" &&
            valArr.length && valArr.length === l) {
        for (var i = 0; i < l; i++) {
            btns[i].style.setProperty(propName, valArr[i], null);
        }
    }else {
        console.error("Style property: " + propName +
            " was unable to be added with the values: " + valArr);
    }
};

HaRadioGroup.prototype.setButtonTitle = function(index, title) {
    var btns = this._btns;
    if (typeof index === "number" && title !== undefined) {
        if (index >= 0 && index < btns.length) {
            btns[parseInt(index, 10)].children[0].innerHTML = title;
        }
    }else {
        console.error(index + " and " + title +
            " are not valid arguments.  Pass a number and string.");
    }
};

HaRadioGroup.prototype.setCSSConfiguration = function(cssConfig) {
    var rules = this._config.CSS;
    for (var prop in cssConfig) {
        if (rules[prop]) {
            rules[prop] = cssConfig[prop];
        }else {
            console.error(prop + " is not a configuration property.");
        }
    }
    this._updateButtons();
};

HaRadioGroup.prototype.setCustomProperty = function(propName, valArr) {
    var btns = this._btns,
        l = btns.length;
    if (typeof propName === "string" && typeof valArr === "object" &&
            valArr.length && valArr.length === l) {
        for (var i = 0; i < l; i++) {
            btns[i][propName] = valArr[i];
        }
    }else {
        console.error("Custom property: " + propName +
            " was unable to be added with the values: " + valArr);
    }
};

HaRadioGroup.prototype.setGutterSize = function(newSize) {
    newSize = typeof newSize === "number" ? newSize + "px" : newSize;

    MEUtil.setRuleProperty("." + this._config.CSS.vertical + ":nth-child(n+2)",
        "margin", newSize + " 0 0 0");
    MEUtil.setRuleProperty("." + this._config.CSS.horizontal + ":nth-child(n+2)",
        "margin", "0 0 0 " + newSize);
};

HaRadioGroup.prototype.setOrientation = function(newOrient) {
    newOrient = newOrient.toLowerCase() || this._orientation;
    if (newOrient === "horizontal" || newOrient === "vertical") {
        if (this._orientation !== newOrient) {
            this._orientation = newOrient;
            this._updateButtons();
        }
    }
};

HaRadioGroup.prototype.setSelectedIndex = function(newSelection, shouldDispatch) {
    if (isNaN(newSelection)) {
        this._unselect(this._selectedBtn);
        this._selectedBtn = null;
    }else {
        if (!this._selectedBtn || newSelection !== this._selectedBtn.haRadioIndex) {
            var btns = this._btns,
                btn = btns[newSelection < -1 ? 0 :
                newSelection >= btns.length ? btns.length - 1 :
                parseInt(newSelection, 10)];

            shouldDispatch = shouldDispatch === undefined ? true : shouldDispatch;

            this._handleBtnPressed(btn);
            this._handleBtnReleased(btn, shouldDispatch);
        }
    }
};

HaRadioGroup.prototype.setTitles = function(newTitles) {
    if (newTitles && newTitles.length) {
        var btns = this._btns;
        for (var i = 0, l = btns.length; i < l; i++) {
            btns[i].children[0].innerHTML = newTitles[i] ||
                btns[i].children[0].innerHTML;
        }
    }else {
        console.error("setTitles: " + newTitles +
            " - value passed was not a valid array.");
    }
};

HaRadioGroup.prototype._addClass = function(element, className) {
    element.classList.add(this._config.CSS[className]);
};

HaRadioGroup.prototype._addTouchListener = function(btn) {
    var eType = MEUtil.IS_TOUCH_DEVICE ? "touchstart" : "mousedown";

    btn.addEventListener(eType, this._eventListener);
};

HaRadioGroup.prototype._addTouchEndListener = function(btn) {
    var onTypes = MEUtil.IS_TOUCH_DEVICE ?
            "touchend touchcancel" : "mouseup mouseout",
        offType = MEUtil.IS_TOUCH_DEVICE ? "touchstart" : "mousedown";

    btn.removeEventListener(offType, this._eventListener);

    MEUtil.on(btn, onTypes, this._eventListener);
};

HaRadioGroup.prototype._attachHandlers = function() {
    var btns = this._btns,
        btn = null;

    for (var i = 0, l = btns.length; i < l; i++) {
        btn = btns[i];
        this._addTouchListener(btn);
    }
};

HaRadioGroup.prototype._createButtonArray = function(srcArr) {
    var btns = [];
    for (var i = 0, l = srcArr.length; i < l; i++) {
        var btn = document.createElement("div");
        btn.appendChild(srcArr[i].cloneNode(true));
        if (srcArr[i].className) {
            btn.userClassName = srcArr[i].className;
        }
        btns[i] = btn;
    }
    return btns;
};

HaRadioGroup.prototype._handleBtnPressed = function(btn, shouldDispatch) {
    this._addClass(btn, "selected");

    this._addTouchEndListener(btn);

    if (shouldDispatch) {
        this._dispatchEvent("touchstart");
    }
};

HaRadioGroup.prototype._handleBtnReleased = function(btn, shouldDispatch) {
    var selectedBtn = this._selectedBtn;
    if (btn) {
        this._removeTouchEndListener(btn);

        if (this._touches && this._touches.length) {
            /*If there are multiple touches*/
            this._unselect(btn);
        }else {
            if (selectedBtn) {
                this._unselect(selectedBtn);
            }
            this._selectedBtn = btn;
            if (shouldDispatch) {
                this._dispatchEvent("change");
            }
        }
    }
};

HaRadioGroup.prototype._mouseHandler = function(event) {
    event.preventDefault();
    var btn = event.currentTarget;
    switch (event.type) {
    case "mousedown":
        if (event.which === 1 && this._isEnabled) {
            this._handleBtnPressed(btn, true);
        }
        break;
    case "mouseout": //Fall-through
    case "mouseup":
        this._handleBtnReleased(btn, true);
    }
};

HaRadioGroup.prototype._removeClass = function(element, className) {
    element.classList.remove(this._config.CSS[className]);
};

HaRadioGroup.prototype._removeTouchEndListener = function(btn) {
    var eTypes = MEUtil.IS_TOUCH_DEVICE ?
        "touchend touchcancel" : "mouseup mouseout";

    MEUtil.off(btn, eTypes, this._eventListener);
};

HaRadioGroup.prototype._touchHandler = function(event) {
    var btn = event.currentTarget;
    this._touches = event.touches;
    switch (event.type) {
    case "touchstart":
        if (this._isEnabled) {
            this._handleBtnPressed(btn, true);
        }
        break;
    case "touchcancel": //Fall-through
    case "touchend":
        this._handleBtnReleased(btn, true);
    }
};

HaRadioGroup.prototype._unselect = function(btn) {
    if (btn) {
        this._removeClass(btn, "selected");
        this._addTouchListener(btn);
    }
};

HaRadioGroup.prototype._updateButtons = function() {
    var btns = this._btns,
        btn = null;

    this._container.innerHTML = "";

    for (var i = 0, l = btns.length; i < l; i++) {
        btn = btns[i];
        btn.haRadioIndex = i;
        btn.style.className = btn.userClassName || "";
        this._addClass(btn, "button");
        this._addClass(btn, this._orientation);
    }

    MEUtil.appendChildren(this._container, btns);
};
